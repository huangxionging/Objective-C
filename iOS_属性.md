## 属性(property

在出现属性以前, 我们创建变量的方式和 C++ 一样, 使用 **@protected**, **@public**, **@private**

```Objective-C
@interface Person: NSObject {
    @public         // 公共变量
        NSString *_name;
        NSInteger _age;
    @protected      // 子类可以访问
        NSArray *_moneys;
    @private        // 私有变量
        NSString *_fatherName;
    @package        // 包内变量, 只能本框架使用
        NSString *_motherName;
}
```
这种方式的缺点:
* **减少冗余代码**: 每个变量都要手动编写 getter, setter 方法, 当变量比较多时, 会出现大量读写代码, 这些读写方法的形式是相同的, 因此会产生代码冗余. property 属性的引入就是将这些读写方法定义封装起来, 减少大量重复的方法定义
* **硬编码, 插入新变量可能会读取错误** 这种类变量定义的方式属于"硬编码", 即对象内部的变量定义和布局已经写死在了编译期, 编译后不可更改, 否则会出错.因为上面的所谓硬编码, 指的是类中的变量会被编译器定义为离对象初始指针地址的偏移量(offset), 编译之后变量是通过地址偏移量来寻找的, 如果要在类中插入新的变量, 则必须要重修编译计算每个变量的偏移量. 都在顺序被打乱会读取错误的变量. 

### Property 属性变量封装定义
存取方法和变量名自动合成
使用 property 属性, 编译器会自动按照严格的存取函数命名规范自动生成对应的存取函数, 通过存取函数就可以根据变量名访问对应的变量. 通过点语法访问变量, 其实就是调用了变量的存取方法(编译器自动完成的), 也就是说通过属性定义的变量名成了存取函数名, 此外还会自动生成对应的实例变量名, 由于自定义的变量名跟获取函数名一样, 为了区分, 实际变量名在前面加下划线. 默认是加下划线, 但还可以是使用 @synthesize 关键字自定义实际变量名. 

### @synthesize 自定义变量名
如果使用 @synthesize 自定义变量名, 则不能使用下划线前缀来访问变量而使用自定义的名字. 实际规范中不太建议使用自定义变量名. (@synthesize 的原始用法和 @property 成对出现来自动合成指定属性变量的存取方法的)

### @dynamic 关键字, 禁止存取方法自动合成 此时如果代码中仍然使用点语法, 或者通过存取函数来读取变量, 编译之前没有异常, 但编译之后由于并没有自动生成存取方法, 运行起来会在存取方法调用的位置处崩溃, 因为调用了不存在的方法.

### 修饰语
* 原子性: nonatomic, atomic
* 读写语义: readwrite, readonly, getter, setter
* 内存管理语义:  assign, weak, unsafe_unretained, retain, strong, copy

其中最重要的是内存管理语义, 要理解内存管理语义的作用和用法, 首先要理解内存管理中的引用计数器原理

* **atomic, nonatomic:** 原子性和非原子性, 原子性是数据库原理中的一个概念. 在多线程中同一个变量可能被多个线程访问, 甚至更改造成数据污染. 因此为了安全, 默认是 atomic 会对 setter 方法枷锁, 相应的也会付出维护原子性(数据加锁解锁) 的系统资源代价. 如果应用中如果不是特殊情况(多线程之间的通讯编程), 一般还是使用 nonatomic 来修饰变量, 不会对 setter 方法加锁, 以提高多线程并发访问性能.

* **readonly, readwrite:** readonly 变量表示只读, 也就是它修饰的变量只有 get 方法没有 set 方法; readwrite 就是既有 get 方法也有 set 方法, 可读可写
* **getter = \<gettername>, setter = \<settername>:** 可以选择性的在括号里直接指定存取方法名
* assign: 直接简单赋值, 主要用于修饰基础数据类型 (例如 NSInteger) 和 C 数据类型 (int, float, double, char 等)上, 或修饰对指针的弱引用;
* **weak** 主要可以用于避免循环引用, 和 strong/retain 对应, 功能上和 assign 一样, 但不同的是用 weak 修饰的对象消失后自动将指针置为 nil, 防止出现悬挂指针, 野指针.
* **unsafe_unretained:** 这种修饰方式不常用, 通过名字看出它是不安全的, 为什么这么说呢? 首先它和 weak 类似都是自己创建并持有的对象之后不会被自己继续持有(引用计数器没有+1, 引用计数为0的时候会被自动释放, unsafe_unretained 和 weak 修饰的指针还指向那个对象) 不同的是在 ARC 中由编译器来自动管理内存, 但 unsafe_unretained 修饰的变量并不会被编译器进行内存管理, 也就是说既不是强引用也不是弱引用, 生成的对象立刻就被释放掉了, 也就是出现了所谓的悬挂指针野指针, 所以不安全
* **retain:** 常用于引用类型, 是为了持有对象, 声明强引用, 将指针指向的旧的引用对象释放掉, 然后将指针指向新的引用对象, 同时将新对象的索引计数加1
* **strong** 原理和 retain 类似, 在 ARC 中替代 retain
* **copy** 建立一个和新对象内容相同且索引计数为1的对象, 指针指向这个对象, 然后释放指针之前指向的旧对象. NSString 变量一般都是用 copy 修饰, 因为字符串常用语直接复制, 而不是取引用某个字符串.

补充:
* **__strong** 对应 strong, retain, copy, 强引用来持有对象.
* **__weak** 修饰符对应于上面的weak 用于防止循环引用.
* **__unsafe__unretained** 修饰符对应于上面的 assign 和 unsafe_unretained, 创建但不持有对象, 可能导致野指针.


